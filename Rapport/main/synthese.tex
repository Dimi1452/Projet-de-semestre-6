% !TeX root = ../Rapport.tex
\section{synthèse}


Dans le cadre de ce projet de semestre, il a été question de réaliser un régulateur auto-ajusté. La méthode à appliquer a été celle de Åström et Hägglund qui consiste à créer une oscillation du système et mesurer 3 grandeurs clés. L'amplitude du régulateur, l'amplitude mesurée du système et enfin la période d'oscillation. \`A partir de ces valeurs, et grâce à la fonction $f(\kappa)=a_0\cdot exp(a_1\kappa +a_2\kappa^2)$ avec les coefficients définit au tableau \ref{tab:Paramètres selon AH}.
Afin d'être efficace durant les phases d'expérimentation, les régulateurs ont été implémentés individuellement (Régulateur à relais et régulateur PID). Sur la maquette n°1, le système étant beaucoup trop oscillant, cette méthode ne fonctionne pas. Il est alors possible pour un tel cas d'utiliser la manière itérative en observant la réponse pour chaque gain changé. On remarque un gain intégrateur supérieur à 100 fois celui utilisé avec la méthode itérative. Les paramètres obtenus ne sont pas concluants. De plus, implémenter un régulateur autoajustable avec le langage de programmation de Saia aurait été fastidieux. Le fait de changer de maquette offre la possibilité de choisir un une commande avec la carte Delfino. L'implémentation de l'autorégulateur s'est déroulée de la même manière que cité précédemment. La différence est que les paramètres obtenus avec le régulateur TOR sont concluants. \`A partir de ces réponses, l'algorithme de l'autoajustage peut être fait. Le diagramme de flux \ref{fig:Diagramme de flux UserTe} présente la réflexion de la fonction UserTe qui est appelée dans le cas final toutes les 200$\mu$s. Afin d'enlever le fruit du hasard, une autre dynamique a été appliquée au moteur en sortie. Une charge supplémentaire a été couplée à l'arbre du moteur DC. Le microprocesseur donne un saut de consigne immédiatement après le calcul des paramètres. (Celui-ci peut être observé avec le signal jaune sur les oscillogrammes précédents) La réponse avec le deuxième moteur couplé, est aussi bonne que sans. Cela implique que la régulation se fait de manière correcte.\\

Points sur lesquels des améliorations peuvent être faites dans le code.
\begin{enumerate}
	\item La plupart des variables sont déclarées "globales"
	\item Déclarer si possible des constantes pour les valeurs qui ne changent pas
	\item Le tableau de valeur pour calculer les amplitudes et la période est très gourmand en ressources (dans ce cas 1000 valeurs en float)
	\item Les boucles "if" imbriquées les une dans les autres pourraient être simplifiées ou optimisées (switch(case))
	\item Les calculs en float sont long et certains peuvent être évités et reprenant la valeur dans une variable calculée précédemment
	\item La structure générale peut être améliorée en créant des fonctions plus spécifiques
\end{enumerate} 

Les points cités ci-dessus ne sont qu'une liste non exhaustive basée sur le code existant. Il est bien entendu possible d'optimiser de manière optimale et de reconsidérer la manière de calcul des grandeurs critiques (amplitude max et période). Le programme est néanmoins fonctionnel et peut être adapté pour un tout autre système. Afin de limiter le traitement du tableau de valeur, il serait possible de faire une moyenne glissante de 4 ou 5 valeurs ceci pour limiter les problèmes dûs au DAC et gagner en rapidité de calcul.\\
Après quelques tests prolongés, il s'avère que des problèmes surviennent quant à l'utilisation du régulateur dans son ensemble. Si on veut calculer les paramètres et que la consigne de position est sur une autre valeur que 0, l'oscillation présente deux ondes négatives et une seule positive (figure \ref{fig:Réponse du système pour la commande autoajustée, avec deux ondulations négatives}). Ceci empêche un calcul correct de la mesure et ne le fait pas remarquer à l'utilisateur. Un autre défaut se manifeste lors de l'appui sur bp1. En effet, après le saut de consigne le moteur tourne en continu alors qu'il devrait réguler à 0.4 (valeur par défaut). Mais lorsque la consigne est appliquée par l'interface de Code Composer Studio, le problème ne se manifeste jamais. Pourtant un système anti-rebond est implémenteé sur la carte.

 Certains oscillogrammes présentent un écart entre la consigne et la position. L'écart sur le logiciel est très faible, mais il est amplifié par cinq lors de sa sortie du DAC.